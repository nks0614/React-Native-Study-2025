# Phase 2 ì‹¤ìŠµ í”„ë¡œì íŠ¸

## ğŸ“Œ í•™ìŠµ ëª©í‘œ

Phase 2ì—ì„œ ë°°ìš´ ê³ ê¸‰ Hooksì™€ ìµœì í™” ê¸°ë²•ì„ ì‹¤ì œ í”„ë¡œì íŠ¸ì— ì ìš©í•˜ì—¬ ì‹¤ë¬´ ê°ê°ì„ í‚¤ì›ë‹ˆë‹¤.

---

## í”„ë¡œì íŠ¸ 1: ì‹¤ì‹œê°„ ê²€ìƒ‰ ê¸°ëŠ¥

### ëª©í‘œ

- useDebounce Custom Hook êµ¬í˜„
- useFetch Custom Hook êµ¬í˜„
- API í˜¸ì¶œ ìµœì í™”

### ìš”êµ¬ì‚¬í•­

1. ì…ë ¥ í•„ë“œì— ê²€ìƒ‰ì–´ ì…ë ¥
2. íƒ€ì´í•‘ ì¤‘ì—ëŠ” API í˜¸ì¶œ ì•ˆ í•¨ (debounce)
3. íƒ€ì´í•‘ ë©ˆì¶˜ í›„ 500ms ë’¤ ìë™ ê²€ìƒ‰
4. ë¡œë”© ìƒíƒœ í‘œì‹œ
5. ê²€ìƒ‰ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ë Œë”ë§

### êµ¬í˜„

```jsx
// hooks/useDebounce.js
import { useState, useEffect } from "react";

function useDebounce(value, delay = 500) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(timer);
  }, [value, delay]);

  return debouncedValue;
}

export default useDebounce;
```

```jsx
// hooks/useFetch.js
import { useState, useEffect, useCallback } from "react";

function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    if (!url) {
      setData(null);
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const response = await fetch(url, options);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const json = await response.json();
      setData(json);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

export default useFetch;
```

```jsx
// components/SearchBox.jsx
import { useState } from "react";
import useDebounce from "../hooks/useDebounce";
import useFetch from "../hooks/useFetch";

function SearchBox() {
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const url = debouncedSearchTerm ? `https://api.github.com/search/users?q=${debouncedSearchTerm}` : null;

  const { data, loading, error } = useFetch(url);

  return (
    <div className="search-box">
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="GitHub ì‚¬ìš©ì ê²€ìƒ‰..."
        className="search-input"
      />

      {loading && <div className="loading">ê²€ìƒ‰ ì¤‘...</div>}
      {error && <div className="error">ì—ëŸ¬: {error}</div>}

      {data && (
        <ul className="search-results">
          {data.items.map((user) => (
            <li key={user.id} className="search-result-item">
              <img src={user.avatar_url} alt={user.login} width={50} />
              <div>
                <h3>{user.login}</h3>
                <a href={user.html_url} target="_blank" rel="noopener noreferrer">
                  í”„ë¡œí•„ ë³´ê¸°
                </a>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default SearchBox;
```

### ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] useDebounce Hook êµ¬í˜„
- [ ] useFetch Hook êµ¬í˜„
- [ ] ê²€ìƒ‰ì–´ ì…ë ¥ ì‹œ debounce ë™ì‘ í™•ì¸
- [ ] ë¡œë”© ìƒíƒœ í‘œì‹œ
- [ ] ì—ëŸ¬ ì²˜ë¦¬
- [ ] ê²€ìƒ‰ ê²°ê³¼ ë Œë”ë§

---

## í”„ë¡œì íŠ¸ 2: ë¬´í•œ ìŠ¤í¬ë¡¤ ë¦¬ìŠ¤íŠ¸

### ëª©í‘œ

- useIntersectionObserver Custom Hook êµ¬í˜„
- ìŠ¤í¬ë¡¤ ê¸°ë°˜ í˜ì´ì§€ë„¤ì´ì…˜
- ì„±ëŠ¥ ìµœì í™” (React.memo)

### ìš”êµ¬ì‚¬í•­

1. ì´ˆê¸° ë°ì´í„° 20ê°œ ë¡œë“œ
2. ìŠ¤í¬ë¡¤ í•˜ë‹¨ ë„ë‹¬ ì‹œ ìë™ìœ¼ë¡œ ë‹¤ìŒ í˜ì´ì§€ ë¡œë“œ
3. ë¡œë”© ì¸ë””ì¼€ì´í„° í‘œì‹œ
4. ëª¨ë“  ë°ì´í„° ë¡œë“œ ì™„ë£Œ ì‹œ ë©”ì‹œì§€ í‘œì‹œ

### êµ¬í˜„

```jsx
// hooks/useIntersectionObserver.js
import { useEffect, useState } from "react";

function useIntersectionObserver(ref, options = {}) {
  const [isIntersecting, setIntersecting] = useState(false);
  const [hasIntersected, setHasIntersected] = useState(false);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new IntersectionObserver(([entry]) => {
      setIntersecting(entry.isIntersecting);

      if (entry.isIntersecting && !hasIntersected) {
        setHasIntersected(true);
      }
    }, options);

    observer.observe(ref.current);

    return () => {
      if (ref.current) {
        observer.unobserve(ref.current);
      }
    };
  }, [ref, options]);

  return { isIntersecting, hasIntersected };
}

export default useIntersectionObserver;
```

```jsx
// hooks/useInfiniteScroll.js
import { useState, useEffect, useCallback } from "react";

function useInfiniteScroll(fetchFunction) {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [error, setError] = useState(null);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore) return;

    try {
      setLoading(true);
      setError(null);

      const newItems = await fetchFunction(page);

      if (newItems.length === 0) {
        setHasMore(false);
      } else {
        setItems((prev) => [...prev, ...newItems]);
        setPage((prev) => prev + 1);
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [page, loading, hasMore, fetchFunction]);

  // ì´ˆê¸° ë¡œë“œ
  useEffect(() => {
    loadMore();
  }, []);

  return { items, loading, hasMore, error, loadMore };
}

export default useInfiniteScroll;
```

```jsx
// components/InfiniteList.jsx
import { useRef, useEffect, memo } from "react";
import useInfiniteScroll from "../hooks/useInfiniteScroll";
import useIntersectionObserver from "../hooks/useIntersectionObserver";

// ê°œë³„ ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸ (ìµœì í™”)
const ListItem = memo(({ item }) => {
  console.log("Rendering item:", item.id);

  return (
    <div className="list-item">
      <h3>{item.title}</h3>
      <p>{item.description}</p>
    </div>
  );
});

function InfiniteList() {
  const loadMoreRef = useRef(null);
  const { isIntersecting } = useIntersectionObserver(loadMoreRef, {
    threshold: 0.5,
  });

  // API í˜¸ì¶œ í•¨ìˆ˜
  const fetchItems = async (page) => {
    const response = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=20`);
    return response.json();
  };

  const { items, loading, hasMore, error, loadMore } = useInfiniteScroll(fetchItems);

  // í•˜ë‹¨ ë„ë‹¬ ì‹œ ìë™ ë¡œë“œ
  useEffect(() => {
    if (isIntersecting && !loading && hasMore) {
      loadMore();
    }
  }, [isIntersecting, loading, hasMore, loadMore]);

  return (
    <div className="infinite-list">
      <h1>ë¬´í•œ ìŠ¤í¬ë¡¤ ë¦¬ìŠ¤íŠ¸</h1>

      <div className="list-container">
        {items.map((item) => (
          <ListItem key={item.id} item={item} />
        ))}
      </div>

      {/* ë¡œë”© ì¸ë””ì¼€ì´í„° */}
      {loading && (
        <div className="loading-indicator">
          <p>ë¡œë”© ì¤‘...</p>
        </div>
      )}

      {/* í•˜ë‹¨ ê°ì§€ ìš”ì†Œ */}
      {hasMore && !loading && <div ref={loadMoreRef} className="load-more-trigger" />}

      {/* ëª¨ë“  ë°ì´í„° ë¡œë“œ ì™„ë£Œ */}
      {!hasMore && (
        <div className="end-message">
          <p>ëª¨ë“  í•­ëª©ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</p>
        </div>
      )}

      {/* ì—ëŸ¬ */}
      {error && (
        <div className="error">
          <p>ì—ëŸ¬: {error}</p>
          <button onClick={loadMore}>ì¬ì‹œë„</button>
        </div>
      )}
    </div>
  );
}

export default InfiniteList;
```

### ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] useIntersectionObserver Hook êµ¬í˜„
- [ ] useInfiniteScroll Hook êµ¬í˜„
- [ ] ìŠ¤í¬ë¡¤ í•˜ë‹¨ ë„ë‹¬ ì‹œ ìë™ ë¡œë“œ
- [ ] ListItemì„ React.memoë¡œ ìµœì í™”
- [ ] ë¡œë”©/ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬
- [ ] ëª¨ë“  ë°ì´í„° ë¡œë“œ ì™„ë£Œ ì‹œ ë©”ì‹œì§€

---

## í”„ë¡œì íŠ¸ 3: ë‹¤í¬ëª¨ë“œ í† ê¸€

### ëª©í‘œ

- useLocalStorage Custom Hook í™œìš©
- Context APIì™€ Custom Hook ì¡°í•©
- í…Œë§ˆ ì „í™˜ ìµœì í™”

### ìš”êµ¬ì‚¬í•­

1. ë¼ì´íŠ¸/ë‹¤í¬ ëª¨ë“œ í† ê¸€
2. ì„ íƒí•œ í…Œë§ˆë¥¼ localStorageì— ì €ì¥
3. í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ì‹œì—ë„ í…Œë§ˆ ìœ ì§€
4. ì „ì—­ ìƒíƒœ ê´€ë¦¬ (Context)

### êµ¬í˜„

```jsx
// hooks/useLocalStorage.js
import { useState, useCallback } from "react";

function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = useCallback(
    (value) => {
      try {
        const valueToStore = value instanceof Function ? value(storedValue) : value;
        setStoredValue(valueToStore);
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      } catch (error) {
        console.error(error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue];
}

export default useLocalStorage;
```

```jsx
// context/ThemeContext.jsx
import { createContext, useContext, useMemo } from "react";
import useLocalStorage from "../hooks/useLocalStorage";

const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useLocalStorage("theme", "light");

  const value = useMemo(
    () => ({
      theme,
      toggleTheme: () => setTheme((prev) => (prev === "light" ? "dark" : "light")),
      setTheme,
    }),
    [theme, setTheme]
  );

  return (
    <ThemeContext.Provider value={value}>
      <div className={`app theme-${theme}`}>{children}</div>
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}
```

```jsx
// components/ThemeToggle.jsx
import { useTheme } from "../context/ThemeContext";

function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();

  return (
    <button onClick={toggleTheme} className="theme-toggle">
      {theme === "light" ? "ğŸŒ™" : "â˜€ï¸"}
      {theme === "light" ? "ë‹¤í¬ ëª¨ë“œ" : "ë¼ì´íŠ¸ ëª¨ë“œ"}
    </button>
  );
}

export default ThemeToggle;
```

```jsx
// App.jsx
import { ThemeProvider } from "./context/ThemeContext";
import ThemeToggle from "./components/ThemeToggle";

function App() {
  return (
    <ThemeProvider>
      <div className="app">
        <header>
          <h1>ë‹¤í¬ëª¨ë“œ ì•±</h1>
          <ThemeToggle />
        </header>

        <main>
          <p>í…Œë§ˆë¥¼ ì „í™˜í•´ë³´ì„¸ìš”!</p>
        </main>
      </div>
    </ThemeProvider>
  );
}

export default App;
```

```css
/* styles.css */
.theme-light {
  --bg-color: #ffffff;
  --text-color: #000000;
  --border-color: #dddddd;
}

.theme-dark {
  --bg-color: #1a1a1a;
  --text-color: #ffffff;
  --border-color: #444444;
}

.app {
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
  transition: background-color 0.3s, color 0.3s;
}

.theme-toggle {
  padding: 10px 20px;
  border: 1px solid var(--border-color);
  background-color: var(--bg-color);
  color: var(--text-color);
  cursor: pointer;
  border-radius: 5px;
  transition: all 0.3s;
}

.theme-toggle:hover {
  transform: scale(1.05);
}
```

### ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] useLocalStorage Hook í™œìš©
- [ ] ThemeContext êµ¬ì„±
- [ ] useTheme Custom Hook êµ¬í˜„
- [ ] í…Œë§ˆ ì „í™˜ ê¸°ëŠ¥
- [ ] localStorage ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°
- [ ] CSS ë³€ìˆ˜ë¡œ í…Œë§ˆ ì ìš©

---

## í”„ë¡œì íŠ¸ 4: ì„±ëŠ¥ ìµœì í™”ëœ ëŒ€ìš©ëŸ‰ ë¦¬ìŠ¤íŠ¸

### ëª©í‘œ

- React.memo, useMemo, useCallback í™œìš©
- ì‹¤ì œ ì„±ëŠ¥ ì¸¡ì •
- ìµœì í™” ì „í›„ ë¹„êµ

### ìš”êµ¬ì‚¬í•­

1. 1000ê°œ ì´ìƒì˜ ì•„ì´í…œ ë¦¬ìŠ¤íŠ¸
2. í•„í„°ë§ ê¸°ëŠ¥
3. ì •ë ¬ ê¸°ëŠ¥
4. ê°œë³„ ì•„ì´í…œ í¸ì§‘ ê°€ëŠ¥
5. ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ìµœì†Œí™”

### êµ¬í˜„

```jsx
// components/OptimizedList.jsx
import { useState, useMemo, useCallback, memo } from "react";

// ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸ (ìµœì í™”)
const ListItem = memo(({ item, onEdit, onDelete }) => {
  console.log("Rendering item:", item.id);

  return (
    <div className="list-item">
      <span>{item.name}</span>
      <span>${item.price}</span>
      <button onClick={() => onEdit(item.id)}>í¸ì§‘</button>
      <button onClick={() => onDelete(item.id)}>ì‚­ì œ</button>
    </div>
  );
});

function OptimizedList() {
  const [items, setItems] = useState(() => {
    // 1000ê°œ ì´ˆê¸° ë°ì´í„° ìƒì„±
    return Array.from({ length: 1000 }, (_, i) => ({
      id: i + 1,
      name: `ìƒí’ˆ ${i + 1}`,
      price: Math.floor(Math.random() * 1000),
      category: ["ì „ì", "ì˜ë¥˜", "ì‹í’ˆ"][Math.floor(Math.random() * 3)],
    }));
  });

  const [filter, setFilter] = useState("");
  const [sortBy, setSortBy] = useState("name");
  const [category, setCategory] = useState("all");

  // í•„í„°ë§ + ì •ë ¬ (ë©”ëª¨ì´ì œì´ì…˜)
  const processedItems = useMemo(() => {
    console.log("í•„í„°ë§+ì •ë ¬ ì‹¤í–‰");

    let result = items;

    // ì¹´í…Œê³ ë¦¬ í•„í„°
    if (category !== "all") {
      result = result.filter((item) => item.category === category);
    }

    // ê²€ìƒ‰ í•„í„°
    if (filter) {
      result = result.filter((item) => item.name.toLowerCase().includes(filter.toLowerCase()));
    }

    // ì •ë ¬
    result = [...result].sort((a, b) => {
      if (sortBy === "name") {
        return a.name.localeCompare(b.name);
      } else if (sortBy === "price") {
        return a.price - b.price;
      }
      return 0;
    });

    return result;
  }, [items, filter, sortBy, category]);

  // í•¸ë“¤ëŸ¬ ë©”ëª¨ì´ì œì´ì…˜
  const handleEdit = useCallback((id) => {
    const newName = prompt("ìƒˆ ì´ë¦„:");
    if (newName) {
      setItems((prev) => prev.map((item) => (item.id === id ? { ...item, name: newName } : item)));
    }
  }, []);

  const handleDelete = useCallback((id) => {
    if (confirm("ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
      setItems((prev) => prev.filter((item) => item.id !== id));
    }
  }, []);

  return (
    <div className="optimized-list">
      <div className="controls">
        <input type="text" value={filter} onChange={(e) => setFilter(e.target.value)} placeholder="ê²€ìƒ‰..." />

        <select value={category} onChange={(e) => setCategory(e.target.value)}>
          <option value="all">ì „ì²´</option>
          <option value="ì „ì">ì „ì</option>
          <option value="ì˜ë¥˜">ì˜ë¥˜</option>
          <option value="ì‹í’ˆ">ì‹í’ˆ</option>
        </select>

        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="name">ì´ë¦„ìˆœ</option>
          <option value="price">ê°€ê²©ìˆœ</option>
        </select>
      </div>

      <p>ì´ {processedItems.length}ê°œ í•­ëª©</p>

      <div className="list-container">
        {processedItems.map((item) => (
          <ListItem key={item.id} item={item} onEdit={handleEdit} onDelete={handleDelete} />
        ))}
      </div>
    </div>
  );
}

export default OptimizedList;
```

### ì„±ëŠ¥ ì¸¡ì •

```jsx
// React DevTools Profiler ì‚¬ìš©
import { Profiler } from "react";

function App() {
  const onRenderCallback = (id, phase, actualDuration, baseDuration, startTime, commitTime) => {
    console.log(`${id} (${phase}):`, {
      actualDuration,
      baseDuration,
    });
  };

  return (
    <Profiler id="OptimizedList" onRender={onRenderCallback}>
      <OptimizedList />
    </Profiler>
  );
}
```

### ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ListItemì„ React.memoë¡œ ê°ì‹¸ê¸°
- [ ] processedItemsë¥¼ useMemoë¡œ ë©”ëª¨ì´ì œì´ì…˜
- [ ] í•¸ë“¤ëŸ¬ë¥¼ useCallbackìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜
- [ ] React DevTools Profilerë¡œ ì„±ëŠ¥ ì¸¡ì •
- [ ] ìµœì í™” ì „í›„ ë Œë”ë§ ì‹œê°„ ë¹„êµ

---

## í”„ë¡œì íŠ¸ 5: API ìºì‹± ì‹œìŠ¤í…œ

### ëª©í‘œ

- useMemoë¥¼ í™œìš©í•œ ì‘ë‹µ ìºì‹±
- ì¤‘ë³µ ìš”ì²­ ë°©ì§€
- ìºì‹œ ë¬´íš¨í™” ì „ëµ

### êµ¬í˜„

```jsx
// hooks/useCachedFetch.js
import { useState, useEffect, useCallback, useRef } from "react";

const cache = new Map();

function useCachedFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const abortControllerRef = useRef(null);

  const fetchData = useCallback(
    async (forceRefresh = false) => {
      if (!url) return;

      // ìºì‹œ í™•ì¸
      if (!forceRefresh && cache.has(url)) {
        console.log("Cache hit:", url);
        setData(cache.get(url));
        return;
      }

      try {
        // ì´ì „ ìš”ì²­ ì·¨ì†Œ
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
        }

        abortControllerRef.current = new AbortController();

        setLoading(true);
        setError(null);

        const response = await fetch(url, {
          ...options,
          signal: abortControllerRef.current.signal,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const json = await response.json();

        // ìºì‹œì— ì €ì¥
        cache.set(url, json);
        setData(json);
      } catch (err) {
        if (err.name !== "AbortError") {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    },
    [url, options]
  );

  const invalidateCache = useCallback(() => {
    cache.delete(url);
    fetchData(true);
  }, [url, fetchData]);

  useEffect(() => {
    fetchData();

    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    refetch: () => fetchData(true),
    invalidateCache,
  };
}

export default useCachedFetch;
```

### ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ìºì‹œ Map êµ¬í˜„
- [ ] ìºì‹œ íˆíŠ¸/ë¯¸ìŠ¤ ë¡œì§
- [ ] ê°•ì œ ìƒˆë¡œê³ ì¹¨ ê¸°ëŠ¥
- [ ] ì¤‘ë³µ ìš”ì²­ ë°©ì§€ (AbortController)
- [ ] ìºì‹œ ë¬´íš¨í™” ê¸°ëŠ¥

---

## ì •ë¦¬

### ì™„ë£Œí•´ì•¼ í•  í”„ë¡œì íŠ¸

- [ ] í”„ë¡œì íŠ¸ 1: ì‹¤ì‹œê°„ ê²€ìƒ‰
- [ ] í”„ë¡œì íŠ¸ 2: ë¬´í•œ ìŠ¤í¬ë¡¤
- [ ] í”„ë¡œì íŠ¸ 3: ë‹¤í¬ëª¨ë“œ í† ê¸€
- [ ] í”„ë¡œì íŠ¸ 4: ì„±ëŠ¥ ìµœì í™” ë¦¬ìŠ¤íŠ¸
- [ ] í”„ë¡œì íŠ¸ 5: API ìºì‹±

### ë°°ìš´ ë‚´ìš©

1. Custom Hooks ì‹¤ì „ í™œìš©
2. ì„±ëŠ¥ ìµœì í™” ê¸°ë²• ì ìš©
3. ì‹¤ì œ ë¬¸ì œ í•´ê²° ê²½í—˜
4. ì½”ë“œ ì¬ì‚¬ìš©ì„± í–¥ìƒ

**ë‹¤ìŒ**: [06-í•™ìŠµ-ì ê²€-ì§ˆë¬¸.md](./06-í•™ìŠµ-ì ê²€-ì§ˆë¬¸.md)
