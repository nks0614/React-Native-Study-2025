# Phase 1 학습 점검 질문

---

## 질문 1: Hooks의 순서가 중요한 이유

### 문제 상황

```jsx
function UserProfile({ isLoggedIn }) {
  const [theme, setTheme] = useState("light");

  if (isLoggedIn) {
    const [user, setUser] = useState(null);
  }

  const [notifications, setNotifications] = useState([]);

  return <View>...</View>;
}
```

### 질문

1. **위 코드의 문제점은 무엇인가요?**
2. **React 내부적으로 왜 이런 에러가 발생하나요? (자료구조 관점에서 설명)**
3. **Android/iOS에서 비슷한 상황이 있다면 무엇인가요?**

### 답변 작성

```
[여기에 답변을 작성하세요]
1. 조건문 내부에 Hook 사용
2. React에서는 순서대로 Hook을 처리하는데 조건문 내부에 있으면 순서 추적이 어려움
3. SwiftUI의 @State var 변수가 조건문 내부에서는 선언 안됨
```

---

<details>

### 1. 문제점

조건문(`if`) 안에서 `useState`를 호출하고 있습니다. 이는 **Hooks의 규칙**을 위반합니다.

### 2. React 내부 동작 원리

**Hook은 연결 리스트로 저장됩니다:**

```javascript
// 첫 번째 렌더링 (isLoggedIn = true)
Fiber.memoizedState → Hook1(theme) → Hook2(user) → Hook3(notifications)

// 두 번째 렌더링 (isLoggedIn = false)
Fiber.memoizedState → Hook1(theme) → Hook2(notifications)
                                      ↑
                              user 대신 notifications를 가져옴!
```

**문제 발생 과정:**

```javascript
// updateWorkInProgressHook 함수
function updateWorkInProgressHook() {
  // 현재 Hook 위치에서 다음 Hook을 가져옴
  nextCurrentHook = currentHook.next;

  // 순서대로 가져오기 때문에
  // Hook이 건너뛰어지면 엉뚱한 값을 가져옴!
}
```

React는 Hook을 **인덱스나 이름이 아닌 순서**로 추적합니다:

- 컴포넌트 렌더링 시 Hook 체인을 처음부터 순회
- `currentHook`을 다음 Hook으로 이동하며 값 반환
- 순서가 바뀌면 잘못된 Hook의 값을 가져옴

### 3. Native와 비교

**Android - ViewModel의 LiveData 순서:**

```kotlin
class MyViewModel : ViewModel() {
    // 이건 괜찮음: 순서가 바뀌어도 이름으로 접근
    val theme = MutableLiveData("light")
    val user = if (isLoggedIn) MutableLiveData<User>() else null
    val notifications = MutableLiveData<List<String>>()
}

// 사용
viewModel.theme.observe(...)  // 이름으로 접근
viewModel.user?.observe(...)
```

**차이점:**

- Android: **이름 기반** 접근 → 순서 무관
- React Hooks: **위치 기반** 접근 → 순서 중요

**iOS - SwiftUI:**

SwiftUI의 `@State`도 비슷한 제약이 있습니다:

```swift
struct ContentView: View {
    @State private var theme = "light"

    // ❌ 조건부 @State는 안됨
    if isLoggedIn {
        @State private var user: User? // 컴파일 에러
    }
}
```

### 올바른 해결책

```jsx
function UserProfile({ isLoggedIn }) {
  const [theme, setTheme] = useState("light");
  const [user, setUser] = useState(null); // 항상 선언
  const [notifications, setNotifications] = useState([]);

  // 조건부로 사용하는 것은 OK
  useEffect(() => {
    if (isLoggedIn) {
      fetchUser().then(setUser);
    } else {
      setUser(null);
    }
  }, [isLoggedIn]);

  return <View>...</View>;
}
```

**핵심 원칙:**

- Hook은 **항상 최상위**에서 선언
- **조건부 사용**은 Hook 내부 로직에서 처리

</details>

---

## 질문 2: State 불변성의 진짜 이유

### 문제 상황

```jsx
function TodoList() {
  const [todos, setTodos] = useState([{ id: 1, text: "Buy milk", done: false }]);

  // 방법 A
  const toggleTodoA = (id) => {
    const todo = todos.find((t) => t.id === id);
    todo.done = !todo.done;
    setTodos(todos);
  };

  // 방법 B
  const toggleTodoB = (id) => {
    setTodos(todos.map((t) => (t.id === id ? { ...t, done: !t.done } : t)));
  };

  return <FlatList data={todos} renderItem={({ item }) => <TodoItem todo={item} />} />;
}

const TodoItem = React.memo(({ todo }) => {
  console.log(`Rendering: ${todo.text}`);
  return <Text>{todo.text}</Text>;
});
```

### 질문

1. **방법 A와 B의 차이점은 무엇인가요?**
2. **React가 방법 A에서 변경을 감지하지 못하는 이유를 메모리 주소 관점에서 설명하세요.**
3. **방법 B가 더 많은 메모리를 사용하는데도 권장되는 이유는 무엇인가요?**
4. **React.memo가 제대로 작동하려면 어떤 방법을 써야 하나요? 왜 그런가요?**

### 답변 작성

```
[여기에 답변을 작성하세요]
1. 방법 A는 기존 객체를 그대로 사용하고 방법 B는 새 객체를 만들어서 사용함
2. React는 메모리 주소 참조에 따라 변경을 감지하는데 기존 객체를 그대로 사용하면 메모리 주소가 바뀌지 않아 감지하지 못함
3. 단기적으로는 더 많은 메모리를 사용하지만, 장기적으로는 얕은 비교를 통한 렌더링 비용이 낮게 나와 성능적으로 향상되기 때문
4. 방법 B, React.memo는 얕은 비교를 통한 props를 구분하고 다르다고 판단될 때 리렌더링을 진행하기에 새 객체를 생성하여 불변성을 유지하는 방법 B가 제대로 동작함
```

---

<details>

### 1. 방법 A vs B 차이점

**방법 A (변경, Mutation):**

- 기존 객체를 **직접 수정**
- 배열 참조는 그대로 유지

**방법 B (불변성, Immutability):**

- **새로운 객체와 배열** 생성
- 참조가 변경됨

### 2. React가 변경을 감지하지 못하는 이유

**메모리 구조:**

```javascript
// 초기 상태
메모리 주소: 0x1000
todos = [
  { id: 1, done: false } ← 주소: 0x2000
]

// 방법 A 실행 후
메모리 주소: 0x1000 (동일!)
todos = [
  { id: 1, done: true } ← 주소: 0x2000 (동일!)
]

// 방법 B 실행 후
메모리 주소: 0x3000 (변경!)
todos = [
  { id: 1, done: true } ← 주소: 0x4000 (변경!)
]
```

**React의 비교 로직:**

```javascript
// dispatchSetState 내부 (간소화)
function dispatchSetState(fiber, queue, action) {
  const currentState = queue.lastRenderedState;
  const eagerState = basicStateReducer(currentState, action);

  // Object.is로 얕은 비교
  if (Object.is(eagerState, currentState)) {
    return; // 리렌더링 스킵!
  }

  scheduleUpdateOnFiber(fiber);
}
```

```javascript
// 방법 A
Object.is(todos, todos) → true
// 같은 참조! → 리렌더링 안 함!

// 방법 B
Object.is(newTodos, todos) → false
// 다른 참조! → 리렌더링!
```

**왜 얕은 비교를 사용하나?**

깊은 비교(Deep Comparison)는 비용이 너무 큽니다:

```javascript
// 깊은 비교 (O(n) - 느림)
function deepEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!deepEqual(a[i], b[i])) return false;
  }
  return true;
}

// 얕은 비교 (O(1) - 빠름)
function shallowEqual(a, b) {
  return a === b; // 참조만 비교
}
```

### 3. 방법 B가 권장되는 이유 (메모리 vs 성능)

**메모리 사용:**

```javascript
// 방법 A: 메모리 재사용
메모리 사용량: 기존 객체 + 0

// 방법 B: 새 객체 생성
메모리 사용량: 기존 객체 + 새 객체
```

하지만 **실제로는 방법 B가 더 효율적**입니다!

**이유 1: 정확한 변경 감지**

```javascript
// 방법 A: 항상 전체 재렌더링
- TodoItem 1 렌더링
- TodoItem 2 렌더링 (변경 안됨에도!)
- TodoItem 3 렌더링 (변경 안됨에도!)

// 방법 B: 변경된 것만 재렌더링
- TodoItem 1 렌더링
- TodoItem 2 스킵 (참조 동일)
- TodoItem 3 스킵 (참조 동일)
```

**이유 2: Time Travel Debugging**

```javascript
// 불변성 유지 → 모든 상태 히스토리 보존
[
  state1, // 이전 상태
  state2, // 중간 상태
  state3, // 현재 상태
];

// Redux DevTools에서 시간 여행 가능!
```

**이유 3: Garbage Collection**

JavaScript 엔진이 사용하지 않는 객체를 자동으로 정리:

```javascript
// 이전 객체: 아무도 참조 안함 → GC가 자동 제거
// 새 객체: 현재 상태가 참조 → 유지
```

### 4. React.memo와의 관계

**방법 A를 사용하면:**

```jsx
const TodoItem = React.memo(({ todo }) => {
  console.log(`Rendering: ${todo.text}`);
  return <Text>{todo.text}</Text>;
});

// 방법 A 실행
toggleTodoA(1);

// React.memo의 비교
prevProps.todo === nextProps.todo
0x2000 === 0x2000 → true

// 결과: 리렌더링 스킵!
// 문제: 화면이 업데이트 안됨! 🐛
```

**방법 B를 사용하면:**

```jsx
// 방법 B 실행
toggleTodoB(1);

// React.memo의 비교
// 변경된 항목
prevProps.todo === nextProps.todo
0x2000 === 0x4000 → false → 리렌더링 ✅

// 변경 안된 항목
prevProps.todo === nextProps.todo
0x2100 === 0x2100 → true → 스킵 ✅
```

**핵심:**

- React.memo는 **얕은 비교** 사용
- 불변성을 지켜야 **정확한 최적화** 가능
- 변경된 부분만 리렌더링 → **전체 성능 향상**

### Android와 비교

**Android - RecyclerView DiffUtil:**

```kotlin
class TodoDiffCallback(
    private val oldList: List<Todo>,
    private val newList: List<Todo>
) : DiffUtil.Callback() {

    override fun areItemsTheSame(oldPos: Int, newPos: Int): Boolean {
        // ID 비교
        return oldList[oldPos].id == newList[newPos].id
    }

    override fun areContentsTheSame(oldPos: Int, newPos: Int): Boolean {
        // 내용 깊은 비교 (비용이 큼!)
        return oldList[oldPos] == newList[newPos]
    }
}
```

**React는 더 효율적:**

- 참조 비교만으로 변경 감지 (O(1))
- 개발자가 불변성 보장하면 DiffUtil 불필요

</details>

---

## 질문 3: Virtual DOM이 정말 빠를까?

### 문제 상황

동료 개발자가 다음과 같이 주장합니다:

> "Virtual DOM은 오버헤드 아닌가요?  
> JavaScript 객체 비교 + 실제 DOM 업데이트 = 2번 작업  
> 그냥 DOM을 직접 업데이트하면 1번만 하면 되는데..."

```javascript
// Virtual DOM 방식 (React)
const prevVDOM = { type: 'div', children: [...100개 항목] };
const nextVDOM = { type: 'div', children: [...1개만 변경] };

// 1. Diff 계산 (JavaScript)
const changes = diff(prevVDOM, nextVDOM);

// 2. DOM 업데이트
applyChanges(changes);

// VS

// 직접 DOM 조작
document.getElementById('item-50').textContent = 'Updated';
```

### 질문

1. **Virtual DOM이 더 느린 경우는 언제인가요? 구체적인 예시를 들어주세요.**
2. **그럼에도 React가 Virtual DOM을 사용하는 진짜 이유는 무엇인가요?**
3. **다음 중 어떤 방식이 더 빠를까요? 이유를 설명하세요.**
   - A: 100개 항목 중 1개를 Virtual DOM으로 업데이트
   - B: 100개 항목을 모두 직접 DOM으로 업데이트
   - C: 1개 항목을 직접 DOM으로 업데이트
4. **Android의 `RecyclerView`와 React의 리스트 렌더링을 비교해주세요.**

### 답변 작성

```
[여기에 답변을 작성하세요]
1. 변경 내역이 단순할 때
2. 선언적 UI, 최소한의 DOM 업데이트 등
3. C < A < B, Dom으로 적은 개수를 조작할때가 제일 빠를거고, A가 Virtual DOM의 이점, B가 일반 DOM의 단점이라 이 순서로 함 
4. 둘 다 View를 재사용한다는 공통점이 있지만, React의 리스트는 선언형 UI고, RecyclerView는 명령형 UI라는 차이가 있음








```

---

<details>

### 1. Virtual DOM이 더 느린 경우

**경우 1: 단일 DOM 조작**

```javascript
// 직접 DOM 조작 (빠름)
document.getElementById("count").textContent = "42";
// 비용: DOM 접근(1) + 업데이트(1) = 2

// React (느림)
setCount(42);
// 비용: setState(1) + Diff(1) + Reconciliation(1) + DOM 업데이트(1) = 4
```

**결론:** 단순한 업데이트는 직접 DOM이 빠름!

**경우 2: 정적 콘텐츠**

```jsx
// React
<View>
  <Text>회사 소개</Text>
  <Text>연락처: 02-1234-5678</Text>
  <Text>주소: ...</Text>
</View>
// 변경이 없는데도 Reconciliation 비용 발생
```

**경우 3: 애니메이션**

```javascript
// requestAnimationFrame + Canvas (빠름)
function animate() {
  ctx.clearRect(0, 0, width, height);
  ctx.fillRect(x, y, 50, 50);
  x += 1;
  requestAnimationFrame(animate);
}

// React (느림)
function AnimatedBox() {
  const [x, setX] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setX((prev) => prev + 1); // 리렌더링 발생!
    }, 16);
  }, []);

  return <View style={{ left: x }} />;
  // 초당 60번 Reconciliation!
}
```

### 2. 그럼에도 Virtual DOM을 사용하는 이유

**이유 1: 복잡한 업데이트의 최적화**

```javascript
// 직접 DOM 조작 - 휴먼 에러 발생
function updateList(items) {
  // 문제: 어떤 항목이 변경/추가/삭제되었는지 직접 추적
  const container = document.getElementById("list");

  // 옵션 A: 전체 재생성 (느림)
  container.innerHTML = "";
  items.forEach((item) => {
    const div = document.createElement("div");
    div.textContent = item.text;
    container.appendChild(div);
  });

  // 옵션 B: 수동 비교 (복잡)
  const existingItems = container.children;
  items.forEach((item, index) => {
    if (!existingItems[index]) {
      // 추가
      const div = document.createElement("div");
      div.textContent = item.text;
      container.appendChild(div);
    } else if (existingItems[index].textContent !== item.text) {
      // 수정
      existingItems[index].textContent = item.text;
    }
  });
  // 삭제 처리는...?
}

// React - 자동 최적화
function List({ items }) {
  return items.map((item) => <Text key={item.id}>{item.text}</Text>);
}
// React가 알아서 최소 변경만 적용!
```

**이유 2: 선언형 프로그래밍**

```javascript
// 명령형 (직접 DOM)
function updateUserUI(user) {
  if (user.isAdmin) {
    document.getElementById("admin-panel").style.display = "block";
    document.getElementById("user-menu").classList.add("admin");
  } else {
    document.getElementById("admin-panel").style.display = "none";
    document.getElementById("user-menu").classList.remove("admin");
  }

  document.getElementById("username").textContent = user.name;

  if (user.avatar) {
    document.getElementById("avatar").src = user.avatar;
  }

  // 상태가 복잡해질수록 관리 지옥...
}

// 선언형 (React)
function UserUI({ user }) {
  return (
    <View>
      {user.isAdmin && <AdminPanel />}
      <Menu className={user.isAdmin ? "admin" : ""} />
      <Text>{user.name}</Text>
      {user.avatar && <Image src={user.avatar} />}
    </View>
  );
}
// 현재 상태만 선언! React가 알아서 업데이트
```

**이유 3: 배치 업데이트**

```javascript
// 직접 DOM - Reflow 3번 발생
function updateThree() {
  div1.style.height = "100px"; // Reflow 1
  div2.style.width = "200px"; // Reflow 2
  div3.textContent = "Hi"; // Reflow 3
  // 매우 느림!
}

// React - Reflow 1번
function Component() {
  setHeight(100);
  setWidth(200);
  setText("Hi");
  // React가 모아서 한 번에 적용 (Commit Phase)
}
```

### 3. 성능 비교

**A: 100개 중 1개를 Virtual DOM으로 업데이트**

```javascript
비용 분석:
- Diff 계산: 100개 비교 = O(100)
- DOM 업데이트: 1개만 = O(1)
총 비용: O(100) + O(1) = O(100)

하지만 Diff는 JavaScript (빠름)
실제 비용: ~0.1ms (Diff) + 0.5ms (DOM) = 0.6ms
```

**B: 100개 모두 직접 DOM 업데이트**

```javascript
비용 분석:
- DOM 업데이트: 100개 = O(100)
- Reflow/Repaint: 여러 번 발생

실제 비용: 100 * 0.5ms + Reflow = ~50ms
```

**C: 1개 항목 직접 DOM 업데이트**

```javascript
비용 분석:
- DOM 업데이트: 1개 = O(1)
- Reflow/Repaint: 1번

실제 비용: ~0.5ms
```

**결론:**

```
C (0.5ms) < A (0.6ms) << B (50ms)
       ↑          ↑
   가장 빠름   거의 비슷    매우 느림
```

**하지만 실제 앱에서는:**

- C는 어떤 1개를 업데이트할지 수동으로 추적해야 함 (복잡!)
- A는 React가 자동으로 1개만 업데이트 (간단!)
- 개발 생산성 vs 0.1ms 차이 → React 승리!

### 4. RecyclerView vs React 리스트

**Android - RecyclerView:**

```kotlin
class TodoAdapter(private val todos: List<Todo>)
    : RecyclerView.Adapter<TodoViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TodoViewHolder {
        // View 재사용 풀에서 가져옴 (또는 생성)
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.todo_item, parent, false)
        return TodoViewHolder(view)
    }

    override fun onBindViewHolder(holder: TodoViewHolder, position: Int) {
        // 재사용된 View에 새 데이터 바인딩
        holder.bind(todos[position])
    }

    override fun getItemCount() = todos.size
}

// 업데이트
adapter.notifyItemChanged(position)  // 수동으로 위치 지정
adapter.notifyDataSetChanged()       // 전체 재렌더링 (느림)

// DiffUtil 사용 (권장)
val diffResult = DiffUtil.calculateDiff(TodoDiffCallback(oldList, newList))
diffResult.dispatchUpdatesTo(adapter)
```

**React - FlatList:**

```jsx
function TodoList({ todos }) {
  return (
    <FlatList
      data={todos}
      keyExtractor={(item) => item.id.toString()}
      renderItem={({ item }) => <TodoItem todo={item} />}
    />
  );
}

const TodoItem = React.memo(({ todo }) => <Text>{todo.text}</Text>);

// 업데이트
setTodos(newTodos); // 자동으로 Diff 계산!
```

**비교:**

| 기능              | RecyclerView           | React FlatList           |
| ----------------- | ---------------------- | ------------------------ |
| **View 재사용**   | ✅ ViewHolder 풀       | ✅ Virtual DOM 재사용    |
| **Diff 계산**     | 🔶 수동 (DiffUtil)     | ✅ 자동 (Reconciliation) |
| **업데이트 추적** | 🔶 수동 (notifyItem\*) | ✅ 자동 (setState)       |
| **메모리 효율**   | ✅ 매우 좋음           | ✅ 좋음                  |
| **개발 편의성**   | 🔶 보일러플레이트 많음 | ✅ 간단                  |

**유사점:**

1. **Windowing (가상화)**

   - RecyclerView: 화면에 보이는 View만 생성
   - FlatList: 화면에 보이는 컴포넌트만 렌더링

2. **재사용**

   - RecyclerView: ViewHolder 재사용
   - React: Virtual DOM 노드 재사용

3. **Key의 중요성**
   - RecyclerView: `getItemId()` 구현
   - React: `key` prop 필수

**차이점:**

```kotlin
// RecyclerView: 위치 기반
adapter.notifyItemMoved(fromPosition, toPosition)
// 개발자가 직접 위치 추적

// React: ID 기반
setTodos(reorderedTodos)
// key로 자동 추적
```

### 핵심 교훈

**Virtual DOM의 가치는 성능이 아니라:**

1. **개발자 경험 (DX)**
   - 선언형 UI
   - 상태만 관리하면 UI는 자동 업데이트
2. **유지보수성**
   - 버그 적음
   - 코드 읽기 쉬움
3. **일관된 최적화**
   - 수동 최적화 불필요
   - React가 알아서 최소 변경 적용

**Dan Abramov (React 핵심 개발자)의 말:**

> "Virtual DOM은 '충분히 빠름'을 보장합니다.  
> 대부분의 경우 성능 걱정 없이 앱을 만들 수 있죠.  
> 진짜 가치는 생산성입니다."

</details>

---

## 추가 도전 과제

### 도전 1: useState를 직접 구현해보기

연결 리스트를 사용하여 실제로 동작하는 useState를 구현하고, 여러 State가 제대로 작동하는지 테스트하세요.

### 도전 2: Reconciliation 시뮬레이터 만들기

간단한 Virtual DOM Diff 알고리즘을 구현하고, key가 있을 때와 없을 때의 차이를 설명해주세요,
